Graphic Features:
• IBL rendering
    • Directional light
    • Scene cube map
    • Sky dome
    • Once implemented, remove gbuffer albedo clear

• GBuffer Render Targets:
    • Normal should be R10G10B10A2
    • Remove Entity ID GBuffer RT
    • Emissive should be RGBA8
        • Optimization opportunity: Separate render pass for objects that have emissive, which should not be alot

• Oct-tree culling on CPU
    • Practically mandatory. Uploading the entire scene's worth of instance transforms every frame cannot scale up.
    • Same for Directional Light Shadow pass
    • Cull objects ONCE per view-proj (Main Camera, each CSM cascade), then re-use culled lists of objects in all Renderers

• True HDR pipeline
    • Luminance Histogram generation
    • Attenuate scene color based on scene luminance (eye adaptation)
    • Tonemapping result & everything after should be in LDR space (RGBA8)

• Shadow mask
    • deferred lighting pass should not compute shadows, only sample shadow mask texture
	• superior soft shadows

• Tile-based Deferred Rendering
    • Support point lights only for now
    • Classify tiles on screen based on complexity
        • nb local lights
        • material complexity?
    • Generate screen-space grid, using grid index as index to lights buffer
    • Dispatch draw calls on screen via DrawIndirect. Build tile screen positions & offsets in separate CS

• Implement Full Z-PrePass
    • Treat every Opaque object as an occluder to keep things simple

• AMD ShadowFX: https://github.com/GPUOpen-Effects/ShadowFX
    
• AMD Combined Adaptive Compute Ambient Occlusion (CACAO):  https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/main/docs/techniques/combined-adaptive-compute-ambient-occlusion.md

• AMD Stochastic Screen-Space Reflections: https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/main/docs/techniques/stochastic-screen-space-reflections.md

• AMD FSR 2.0: https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/main/docs/techniques/super-resolution-temporal.md

///////////////////////////////////////////////////////////////////////////////
Engineering Tasks:
• Move IMGUI rendering to its own GfxRenderer

• Convert all Shaders to HLSL syntax & use ShaderMake :)

• Standardize resource SRV and UAV access in each GfxRenderer
	• Have an initial state that each resource should be in
	• If the renderer needs to use the resource it has the responsilibity to return it to the initial state

• Proper Frame Fencing
    • Should only stall CPU before the FIRST command buffer submission

• HDR Render Targets:
	• Should be R10G10B11
	• Should return to RGBA8 after tonemapping

• GPU-driven renderer
    • Implement this Step-by-Step. This is a huge & complex undertaking with multiple chained indirect dispatches
    • 1st Evolution: Batch & dispatch draw calls on CPU first
        • Since you already have virtual vertex & index buffers, and bindless textures, you only need to batch by Mesh
    • 2nd evolution: occlusion cull batches (ZPrePass needed)
        • Increment instance count if not culled, and append instance data to external buffer
        • DispatchIndirect using InstanceCount buffer as draw parameter buffer
        • BONUS: Compact buffer to get rid of empty draw calls (put a wall in between all meshes to test)
        • Will still require 1 DispatchIndirect per mesh batch
    • 3rd evolution: Generate batches on GPU
        • Upload all CPU-culled instance data in a linear buffer to culling CS 
            • All batches in one go
        • Build batches in CS. Internally "bucketize" batches in external linear buffer, generate appropriate offsets to external buffers
        • If done properly, 1 DispatchIndirect for whole scene
            • Only because everything uses the same uber GBuffer Shader, else its 1 DispatchIndirect per Shader

• Separate GBuffer draw call specifically for skinned meshes
    • Can (should) be run in parallel in another thread & Renderer
    • dont mix with static non-skinned meshes
    • the 'skinned' bool should not be information from the instance
        • it shouldbe from a constant buffer, like say, a PassContext UBO
        • Best if it's a separate Shader Permutation

• Use giant GPU circular buffers for gpu instance transforms
    • Suballocate exact necessary bytes as neededed for culled instances
    • Pass buffer offset to VS

• Don't clear GBuffer every frame
    • Your game should have every pixel in every GBuffer Render Target filled up.

• Encapsulate as many Vulkan API calls as possible inside your "CommandList" class

• Multi-thread all Graphic Tasks & Renderers
	• Must be pooled per-thread
    • Implement free-list of command buffers. They must all be properly fenced before re-used

• Render Graph
    • Scheduling of asynchronous compute fences
    • Allocation of transient resources with optimal lifetimes and memory aliasing
    • Transitioning of sub-resources using split-barriers to hide latency and improve overlap on the GPU
    • Parallel command list recording
    • Culling of unused resources and passes in the graph
    • Validation of usage and resource dependencies

• Compute Queue
    • Anything that can be run asyncronously with Graphics Queue, should
    • GPU Fence where necessary


///////////////////////////////////////////////////////////////////////////////
Done:
• Get rid of RenderPassDatabase
    • dynamic_cast is not allowed in most AAA game engines
    • It's linearly iterating through all Renderers & dynamic casting, which is bad for perf
    • It's also not necessary. Just declare a Renderer in Global scope in its own .cpp file, and extern the GfxRenderpass ptr in VulkanRenderer.

• Vulkan Memory Allocator: https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator
	• Fully integrated

• Separate sampler from image
    • create & store globally accessible common samplers to use & bind, such as Linear-Clamp, Point-Wrap etc...

• Shader hot-reloading

• Seperation of mipmaps generation from texture

• Automatic texture mip generation on GPU
    • Utilize this if you want: https://github.com/GPUOpen-LibrariesAndSDKs/FidelityFX-SDK/blob/main/docs/techniques/single-pass-downsampler.md
    • Use anisotropic sampler in GBuffer Pass
	
• Change to from Vulkan renderpasses to VK_KHR_dynamic_rendering

• Support only 1 queue for now
	• Remove transfer queue
	
• Remove all forms of binary semaphores
	• Implement a frame counter and semaphore signal at end of present
	• Only left with necessary semaphores for acquireImage

• Implement frame based deleter
	• Use VK_SEMAPHORE_TYPE_TIMELINE counting semaphore to check frame on GPU
	
• Use Inverse Depth Buffer & Infinite Far Plane for your Projection Matrix

• Get rid of presentation queue. Present on Graphics Queue

• No try-catch. Unacceptable method of error handling unless it's extremely specific edge case
    • Get rid of all try-catch
    • Use asserts instead, or use "__debugbreak()"
	
• Always enable VK_LAYER_KHRONOS_validation
    • Don't ignore any non-verbose messages

• Get rid of "Debug" config. Only Release from now onwards
    • Use pragma optimize("", off) to debug code
	
• Only support 1 Camera


